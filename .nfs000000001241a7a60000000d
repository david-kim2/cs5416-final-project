#!/bin/bash
# Automated script to test batch size tradeoffs
# Tests different batch size configurations and measures throughput vs memory
# Usage: ./run_batch_experiment.sh

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
NODE_0_IP="${NODE_0_IP:-localhost:8000}"
NODE_1_IP="${NODE_1_IP:-localhost:8001}"
NODE_2_IP="${NODE_2_IP:-localhost:8002}"
FAISS_INDEX_PATH="${FAISS_INDEX_PATH:-faiss_index.bin}"
DOCUMENTS_DIR="${DOCUMENTS_DIR:-documents/}"

# Test configurations: MIN_BATCH_SIZE MAX_BATCH_SIZE BASE_BATCH_SIZE
declare -a BATCH_CONFIGS=(
    "1 4 2"
    "2 8 4"
    "4 16 8"
    "8 32 16"
)

declare -a CONFIG_NAMES=(
    "Small (1-4)"
    "Medium (2-8)"
    "Large (4-16)"
    "XL (8-32)"
)

RESULTS_FILE="batch_size_results.txt"
TEMP_DIR="/tmp/batch_experiment_$$"

# Cleanup function
cleanup() {
    echo -e "\n${YELLOW}Cleaning up...${NC}"
    # Kill any running nodes
    for port in 8000 8001 8002; do
        lsof -ti:$port 2>/dev/null | xargs kill -9 2>/dev/null || true
    done
    rm -rf "$TEMP_DIR"
}

trap cleanup EXIT INT TERM

# Function to check if a port is in use
check_port() {
    local port=$1
    lsof -ti:$port >/dev/null 2>&1
}

# Function to wait for service to be ready
wait_for_service() {
    local url=$1
    local max_wait=60
    local waited=0
    
    while [ $waited -lt $max_wait ]; do
        if curl -s -f "http://${url}/health" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done
    return 1
}

# Function to measure memory usage
measure_memory() {
    local total_mb=0
    for port in 8000 8001 8002; do
        local pid=$(lsof -ti:$port 2>/dev/null)
        if [ -n "$pid" ]; then
            local mem_kb=$(ps -o rss= -p $pid 2>/dev/null | tr -d ' ')
            if [ -n "$mem_kb" ]; then
                local mem_mb=$(echo "scale=2; $mem_kb / 1024" | bc)
                total_mb=$(echo "scale=2; $total_mb + $mem_mb" | bc)
            fi
        fi
    done
    echo "$total_mb"
}

# Function to start nodes with a configuration
start_nodes() {
    local min_batch=$1
    local max_batch=$2
    local base_batch=$3
    
    echo -e "${GREEN}Starting nodes with batch config: MIN=$min_batch MAX=$max_batch BASE=$base_batch${NC}"
    
    # Start Node 0
    MIN_BATCH_SIZE=$min_batch MAX_BATCH_SIZE=$max_batch BASE_BATCH_SIZE=$base_batch \
    TOTAL_NODES=3 NODE_NUMBER=0 \
    NODE_0_IP=$NODE_0_IP \
    NODE_1_IP=$NODE_1_IP \
    NODE_2_IP=$NODE_2_IP \
    FAISS_INDEX_PATH=$FAISS_INDEX_PATH \
    DOCUMENTS_DIR=$DOCUMENTS_DIR \
    ./run_distributed.sh > "$TEMP_DIR/node0.log" 2>&1 &
    local node0_pid=$!
    echo "Node 0 started (PID: $node0_pid)"
    
    # Start Node 1
    MIN_BATCH_SIZE=$min_batch MAX_BATCH_SIZE=$max_batch BASE_BATCH_SIZE=$base_batch \
    TOTAL_NODES=3 NODE_NUMBER=1 \
    NODE_0_IP=$NODE_0_IP \
    NODE_1_IP=$NODE_1_IP \
    NODE_2_IP=$NODE_2_IP \
    FAISS_INDEX_PATH=$FAISS_INDEX_PATH \
    DOCUMENTS_DIR=$DOCUMENTS_DIR \
    ./run_distributed.sh > "$TEMP_DIR/node1.log" 2>&1 &
    local node1_pid=$!
    echo "Node 1 started (PID: $node1_pid)"
    
    # Start Node 2
    MIN_BATCH_SIZE=$min_batch MAX_BATCH_SIZE=$max_batch BASE_BATCH_SIZE=$base_batch \
    TOTAL_NODES=3 NODE_NUMBER=2 \
    NODE_0_IP=$NODE_0_IP \
    NODE_1_IP=$NODE_1_IP \
    NODE_2_IP=$NODE_2_IP \
    FAISS_INDEX_PATH=$FAISS_INDEX_PATH \
    DOCUMENTS_DIR=$DOCUMENTS_DIR \
    ./run_distributed.sh > "$TEMP_DIR/node2.log" 2>&1 &
    local node2_pid=$!
    echo "Node 2 started (PID: $node2_pid)"
    
    # Wait for all nodes to be ready
    echo "Waiting for nodes to initialize (up to 5 minutes)..."
    local all_ready=false
    for i in {1..60}; do
        if wait_for_service "$NODE_0_IP" && \
           wait_for_service "$NODE_1_IP" && \
           wait_for_service "$NODE_2_IP"; then
            all_ready=true
            break
        fi
        sleep 5
        echo -n "."
    done
    echo ""
    
    if [ "$all_ready" = true ]; then
        echo -e "${GREEN}All nodes are ready!${NC}"
        sleep 2  # Give nodes a moment to stabilize
        return 0
    else
        echo -e "${RED}Nodes failed to start within timeout${NC}"
        return 1
    fi
}

# Function to stop all nodes
stop_nodes() {
    echo "Stopping all nodes..."
    for port in 8000 8001 8002; do
        lsof -ti:$port 2>/dev/null | xargs kill -9 2>/dev/null || true
    done
    sleep 2
    echo "Nodes stopped"
}

# Function to run client test
run_client_test() {
    local num_requests=${1:-20}
    local interval=${2:-5}
    
    echo "Running client test: $num_requests requests, $interval second intervals..."
    
    # Run client and capture output
    NODE_0_IP=$NODE_0_IP python3 client.py --num-requests $num_requests --interval $interval > "$TEMP_DIR/client_output.txt" 2>&1
    
    # Extract metrics from output
    local avg_latency=$(grep -oP 'Average latency: \K[0-9.]+' "$TEMP_DIR/client_output.txt" || echo "0")
    local throughput=$(grep -oP 'Throughput: \K[0-9.]+' "$TEMP_DIR/client_output.txt" || echo "0")
    local successful=$(grep -oP 'Successful responses: \K[0-9]+' "$TEMP_DIR/client_output.txt" || echo "0")
    
    echo "$avg_latency|$throughput|$successful"
}

# Main experiment
main() {
    echo "============================================================"
    echo "BATCH SIZE TRADEOFF EXPERIMENT"
    echo "============================================================"
    echo ""
    echo "This script will:"
    echo "  1. Test ${#BATCH_CONFIGS[@]} different batch size configurations"
    echo "  2. Measure memory usage for each"
    echo "  3. Test throughput and latency"
    echo "  4. Generate a results table"
    echo ""
    echo "Press Enter to continue or Ctrl+C to cancel..."
    read
    
    # Create temp directory
    mkdir -p "$TEMP_DIR"
    
    # Initialize results file
    echo "Batch Size Tradeoff Experiment Results" > "$RESULTS_FILE"
    echo "======================================" >> "$RESULTS_FILE"
    echo "Date: $(date)" >> "$RESULTS_FILE"
    echo "" >> "$RESULTS_FILE"
    echo "| Config | Memory (MB) | Avg Latency (s) | Throughput (req/min) | Successful |" >> "$RESULTS_FILE"
    echo "|--------|-------------|-----------------|---------------------|------------|" >> "$RESULTS_FILE"
    
    # Test each configuration
    for i in "${!BATCH_CONFIGS[@]}"; do
        local config="${BATCH_CONFIGS[$i]}"
        local name="${CONFIG_NAMES[$i]}"
        local min_batch=$(echo $config | cut -d' ' -f1)
        local max_batch=$(echo $config | cut -d' ' -f2)
        local base_batch=$(echo $config | cut -d' ' -f3)
        
        echo ""
        echo "============================================================"
        echo "Testing Configuration $((i+1))/${#BATCH_CONFIGS[@]}: $name"
        echo "MIN_BATCH_SIZE=$min_batch MAX_BATCH_SIZE=$max_batch BASE_BATCH_SIZE=$base_batch"
        echo "============================================================"
        
        # Stop any existing nodes
        stop_nodes
        
        # Start nodes with this configuration
        if ! start_nodes $min_batch $max_batch $base_batch; then
            echo -e "${RED}Failed to start nodes for config $name${NC}"
            echo "| $name | FAILED | - | - | - |" >> "$RESULTS_FILE"
            continue
        fi
        
        # Measure memory
        echo "Measuring memory usage..."
        sleep 3  # Let memory stabilize
        local memory=$(measure_memory)
        echo "Total Memory: ${memory} MB"
        
        # Run client test
        local test_results=$(run_client_test 20 5)
        local avg_latency=$(echo $test_results | cut -d'|' -f1)
        local throughput=$(echo $test_results | cut -d'|' -f2)
        local successful=$(echo $test_results | cut -d'|' -f3)
        
        # Record results
        echo "| $name | ${memory} | ${avg_latency} | ${throughput} | ${successful} |" >> "$RESULTS_FILE"
        
        echo ""
        echo -e "${GREEN}Results for $name:${NC}"
        echo "  Memory: ${memory} MB"
        echo "  Avg Latency: ${avg_latency} seconds"
        echo "  Throughput: ${throughput} requests/minute"
        echo "  Successful: ${successful}/20"
        
        # Stop nodes before next test
        stop_nodes
        sleep 3
    done
    
    # Print final results
    echo ""
    echo "============================================================"
    echo "EXPERIMENT COMPLETE!"
    echo "============================================================"
    echo ""
    echo "Results saved to: $RESULTS_FILE"
    echo ""
    cat "$RESULTS_FILE"
    echo ""
    echo "============================================================"
}

# Check dependencies
if ! command -v bc &> /dev/null; then
    echo -e "${RED}Error: 'bc' command not found. Please install it.${NC}"
    echo "  Ubuntu/Debian: sudo apt-get install bc"
    echo "  macOS: brew install bc"
    exit 1
fi

# Run main function
main

